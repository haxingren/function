#define _CRT_SECURE_NO_WARNINGS

//递归 一种程序调用自身的编程技巧
//通常把一个大小复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解
//只需少量的程序就能描述出解题过程所需要的多次重复计算，大大减少程序的代码量
//主要思考方式为 大事化小

//递归的必要条件
//1存在限制条件，满足限制条件时，递归便不再继续
//2每次递归调用后，都要越来越接近限制条件

#include <stdio.h>


//例子1
//用递归写一个函数依次打印出1234的每一个数字
void print(unsigned int n)
{
	if (n > 9)
	{
		print(n/10);
	}
	printf("%u ", n % 10);
}
//这个递归函数的原理大致以下函数
void print2(unsigned int n)
{
	if (n > 9)//这个if是必须的，要给函数一个满足条件停止递归，否则会进入死递归，无限调用函数，直到崩溃（栈区爆满），因为函数的调用都会在栈区申请内存
	//一开始进函数n是1234
	{
		n = n / 10;//得123
		if (n > 9)//每一次进入下一次递归时都会减少n的最后一位数
		{
			n = n / 10;//12
			if (n > 9)
			{
				n = n / 10;//1
				if (n > 9)
				{
					n = n / 10;
				}
				else					  //进入最后一层后满足限制条件，不再套层，进入下一步
					printf("%u ", n % 10);//打印出第一个数字1后才回到上一层
				printf("%u ", n % 10);//继续打印第二位2，再回到上一层
			}
			printf("%u ", n % 10);//打印第三位3
		}
	}
	printf("%u ", n % 10);//打印第四位
}
//这个函数只是大致表示出递归函数的算法思路，其实效果并不一样，因为这个函数的n模10后就被保存了，最后只剩1 1 1 1，
//而递归函数，每一次调用里函数内的参数并不会被改动，所以可以1 2 3 4


//例子2
//写一个函数模拟库函数strlen
//不允许使用临时变量

////int my_strlen(char str[])//参数部分写出数组的形式
//int my_strlen(char* str)//参数部分写出指针的形式
////接收arr首元素地址，根据地址找到arr并对其操作
//{
//	int count = 0;
//	while ((*str) != '\0')
//	{
//		str++;//地址+1，找到下一个元素
//		count++;//计数，临时变量
//	}
//	return count;
//}//使用了临时变量，重写

//my_strlen("abc");
//1+my_strlen("bc");
//1+（1+my_strlen("c")）;
//1+（1+1my_strlen("");
//1+1+1+0
int my_strlen(char* str)
{
	if ((*str) != 0)
	{
		return 1 + my_strlen(++str);
	}
	else
		return 0;
}
int main()
{
	////用递归写一个函数依次打印出1234的每一个数字
	//unsigned int num = 0;
	//scanf("%u", &num);
	//print2(num);


	//模拟库函数
	char arr[] = { "abc" };
	int len = my_strlen(arr);//看起来是传数组，其实是传数组首元素的地址给函数
	printf("%d\n", len);
	return 0;
}